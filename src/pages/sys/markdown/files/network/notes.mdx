# Networking summary

## Visiting a page

### Resolving IP of page

1. Check local DNS cache (browser, OS)
2. Resolving nameserver (Internet Service Provider)
3. Root nameserver
4. Top Level Domain server (.com, .net etc.)
5. Authoritative DNS: DNS server of organization operating website, should have IP. (e.g. namecheap)

note: DNS resolution uses UDP. Use DNS over HTTPS to encrypt for privacy (default for firefox US).

### Initiate TCP connection

1. Client sends SYN packet to server
2. Server responds with SYN + ACK
3. Client sends ACK to server

### Establish HTTPS

[reference](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/)
1. Client sends `Client hello` + cipher suites + client random + Diffie Hellman parameters
2. Server responds with `Server hello` + SSL Certificate (from CA authority) + server random + selected cipher suite + server random
    - server sends the `Finish` message, since it can calculate shared key already
3. Client calculate shared key from Diffie Hellman parameters + server random, send client `Finish`.

### Send HTTP request

1. send a GET request for the resources.
2. server responds with the resources.

### Misc trivia
- http port 80, https port 443
- `keep-alive` required to avoid having to `hello` each time a resource is requested (http, css, image).


## Internet layers

1. **Application**: HTTP, SMTP, actual data
2. **Transport**: process to process, TCP/UDP
3. **Network**: routing, source to dest. IP, routing protocols
4. **Link**: MAC address, home routers etc.
5. **Physical**: actual bits

## HTTP

### request components

- verb: `GET`, `POST`, `HEAD`(1.0), `PUT`, `DELETE`(1.1)

### response components
- response code
  1. `1XX` (information)
  2. `2XX` (success: `200 ok`, `201 created`, `202 accepted`)
  3. `3XX` (redirection: `301 moved permanently`)
  4. `4XX` (Client error)
  5. `5XX` (Server error)

## Transport protocols

### TCP

#### Features
- congestion control: throttle sender when network overloaded
- reliable: resend if no ACK
- Flow control: `rwnd` allows sender to control how much data receiver sends
- connection oriented: for each unique(src IP, src Port), server creates a new socket. client new socket for each port.
- No minimum throughput, no security

#### Datagram
<table>
  <tr>
    <td colSpan="16">src port</td>
    <td colSpan="16">dest port</td>
  </tr>
  <tr>
    <td colSpan="32">seq number</td>
  </tr>
  <tr>
    <td colSpan="32">ack number</td>
  </tr>
  <tr>
    <td colSpan="4">header length</td>
    <td colSpan="18"></td>
    <td>Urgent</td>
    <td>Ack</td>
    <td>Push</td>
    <td>Reset</td>
    <td>Syn</td>
    <td>Fin</td>
    <td colSpan="4">Receive Window</td>
  </tr>
  <tr>
    <td colSpan="24">checksum</td>
    <td colSpan="8">urgent pointer</td>
  </tr>
  <tr>
    <td colSpan="32">options</td>
  </tr>
</table>

- `sequence no`: packet no, e.g. 1000 bytes Maximum Segment Size, seq no = (0, 1000, 2000, 3000...)
- `ACK no`: first byte of next packet expected
- `checksum`: same as UDP
- `head len`: header length
- `U`: contains urgent. read urgent data ptr and send up first
- `A`: contains ack, parse ack no.
- `P`: like urgent but push entire segment
- `R`: RST, reset: unable to parse, incorrect format etc.
- `S`: SYN, sync flag for handshake
- `F`: FIN, finish flag for closing
- `rwnd`/ Receive Window: no. of bytes receiver willing to accept, i.e. remaining free buffer

#### Process

1. Handshaking:
   1. client `LISTEN` send server `SYN`, seq = `x`. state change `SYN_SENT`
   2. server receive, state `LISTEN` to `SYN RCVD`. ACK with `SYN`, seq = `y`, ack = `x + 1`
   3. client receive, state `ESTAB`. ACK with `y + 1`. server state `ESTAB` on receive
2. closing TCP:
   1. client send server w/ `FIN` flag and seq = `x`, state becomes `FIN_WAIT_1`, cannot send anymore
   2. server ACK w/ `x + 1`, server state `CLOSE_WAIT`, server can still send. client receive, state becomes `FIN_WAIT_2`
   3. server does cleanup, send `FIN` flag segment w/ seq = `y`, server state `LAST_ACK`, cannot send. client state `TIMED_WAIT`
   4. client ACK `y + 1`, then wait 2x max segment lifetime before state `CLOSED`. server state `CLOSED` on receive ACK

#### TCP ACK generation

1. in order: delay 500ms, send ack
2. in order, pending ACK ^ not yet sent: immediate send ACK
3. out of order: immediate send dupe ACK
4. in order, out of order previously received: immediate ACK

- uses either Go Back N or Selective Repeat. buffer not in specification but usually both sender and recv have.
- ACK cumulative, ACK no = next packet expected

#### Timeout calculation

1. EstimatedRTT = (1 - x) * EstimatedRTT + x * SampleRTT`, `x` usually 1/8. `SampleRTT` = latest RTT
2. `DevRTT aka safety margin = (1-y) * DevRTT + y * |SampleRTT - EstimatedRTT|`, `y` usually 1/4. Deviation from mean
3. `Timeout = EstimatedRTT + 4 * DevRTT`

#### TCP fast retransmit

- If 4 un ACK'd segments received, resend even if not yet timeout

### UDP, User Datagram Protocol:

#### Datagram
<table>
  <tr>
    <td colSpan="16">src port</td>
    <td colSpan="16">dest port</td>
  </tr>
  <tr>
    <td colSpan="16">length</td>
    <td colSpan="16">checksum</td>
  </tr>
</table>


- Unreliable, does not have any features not in TCP
- Length includes header
- no handshake/setup. UDP has no idea if server received properly
- **Connectionless demultiplexing**: 1 socket for all client. sender attaches destination `IP` + `port`. Server use same port/socket for all.
- Checksum: detects errors. Keep summing 16 bit chunks of data. if MSB carry, wraparound to back. Invert sum to get checksum
- Used for DNS lookup.

```
x = 10...0
y = 10...0
+_________
   100...0(sum w/ MSB carry over)
    00...1(sum w/ wraparound)
__________
~   11...0(checksum)
```
